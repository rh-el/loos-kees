{"version":3,"file":"RelatedTagsParser.js","sourceRoot":"","sources":["../../../../src/lib/tag/RelatedTagsParser.ts"],"names":[],"mappings":";;;;;;;;AAEA,gDAA+C;AAE/C,MAAqB,iBAAiB;IAEpC,MAAM,CAAC,gBAAgB,CAAC,IAAS;QAC/B,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;YAC7B,MAAM,MAAM,GAAgB;gBAC1B,MAAM,EAAE,EAAE;gBACV,KAAK,EAAE,EAAE;aACV,CAAC;YACF,IAAI,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;gBAC9D,MAAM,CAAC,MAAM,GAAI,IAAI,CAAC,cAAwB,CAAC,MAAM,CAAwB,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE;oBACtF,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,CAAC;wBACrG,MAAM,GAAG,GAAQ;4BACf,IAAI,EAAE,KAAK;4BACX,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI;4BAChB,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,SAAS;yBACvB,CAAC;wBACF,GAAG,CAAC,IAAI,CAAC;4BACP,GAAG;4BACH,OAAO,EAAE,uBAAA,IAAI,wCAAW,MAAf,IAAI,EAAY,CAAC,CAAC,YAAY,CAAC;yBACzC,CAAC,CAAC;oBACL,CAAC;oBACD,OAAO,GAAG,CAAC;gBACb,CAAC,EAAE,EAAE,CAAC,CAAC;YACT,CAAC;YACD,IAAI,IAAI,CAAC,aAAa,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC;gBAC5D,MAAM,CAAC,KAAK,GAAG,uBAAA,IAAI,wCAAW,MAAf,IAAI,EAAY,IAAI,CAAC,aAAa,CAAC,CAAC;YACrD,CAAC;YACD,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,MAAM,IAAI,qBAAU,CAAC,4CAA4C,EAAE,IAAI,CAAC,CAAC;IAC3E,CAAC;CAcF;6FAZmB,IAAW;IAC3B,OAAO,IAAI,CAAC,MAAM,CAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC;YACnD,MAAM,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,KAAK;gBACX,IAAI,EAAE,CAAC,CAAC,IAAI;gBACZ,KAAK,EAAE,CAAC,CAAC,SAAS;aACnB,CAAC,CAAC;QACL,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC;kBA5CkB,iBAAiB","sourcesContent":["import {type RelatedTags} from \"../types/Tag.js\";\nimport type Tag from \"../types/Tag.js\";\nimport { ParseError } from \"../utils/Parse.js\";\n\nexport default class RelatedTagsParser {\n\n  static parseRelatedTags(json: any) {\n    if (typeof json === 'object') {\n      const result: RelatedTags = {\n        single: [],\n        combo: []\n      };\n      if (json.single_results && Array.isArray(json.single_results)) {\n        result.single = (json.single_results as any[]).reduce<RelatedTags['single']>((acc, v) => {\n          if (typeof v === 'object' && v.tag && v.tag.name && v.tag.norm_name && Array.isArray(v.related_tags)) {\n            const tag: Tag = {\n              type: 'tag',\n              name: v.tag.name,\n              value: v.tag.norm_name\n            };\n            acc.push({\n              tag,\n              related: this.#parseTags(v.related_tags)\n            });\n          }\n          return acc;\n        }, []);\n      }\n      if (json.combo_results && Array.isArray(json.combo_results)) {\n        result.combo = this.#parseTags(json.combo_results);\n      }\n      return result;\n    }\n\n    throw new ParseError('Failed to parse related tags: invalid data', json);\n  }\n\n  static #parseTags(tags: any[]) {\n    return tags.reduce<Tag[]>((result, t) => {\n      if (typeof t === 'object' && t.name && t.norm_name) {\n        result.push({\n          type: 'tag',\n          name: t.name,\n          value: t.norm_name\n        });\n      }\n      return result;\n    }, []);\n  }\n}"]}