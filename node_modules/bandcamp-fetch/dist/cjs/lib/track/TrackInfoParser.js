"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _TrackInfoParser_parseTrackInfoFromAlbum;
Object.defineProperty(exports, "__esModule", { value: true });
const cheerio_1 = require("cheerio");
const html_entities_1 = require("html-entities");
const Parse_js_1 = require("../utils/Parse.js");
const AlbumInfoParser_js_1 = __importDefault(require("../album/AlbumInfoParser.js"));
class TrackInfoParser {
    static parseInfo(html, opts) {
        // Some tracks don't have a dedicated '/track' url,
        // But take this form instead: {albumUrl}#t{x}, where 'x' is the
        // Track position. These tracks are not displayed as links nor playable.
        // Since the album page is actually loaded, we can return the track info
        // From the album data with parseAlbumInfo().
        if (opts.trackUrl) {
            const { path: trackUrlPath, hash: trackUrlHash } = (0, Parse_js_1.splitUrl)(opts.trackUrl);
            if (trackUrlPath && trackUrlHash) {
                const matchTrackPosInUrl = (/^\/(album)\/(.+)#t(\d+)/).exec(trackUrlPath + trackUrlHash);
                if (matchTrackPosInUrl && matchTrackPosInUrl[3]) {
                    return __classPrivateFieldGet(this, _a, "m", _TrackInfoParser_parseTrackInfoFromAlbum).call(this, html, opts, Number(matchTrackPosInUrl[3]));
                }
            }
        }
        const $ = (0, cheerio_1.load)(html);
        const rawBasic = $('script[type="application/ld+json"]').html();
        const rawExtra = (0, html_entities_1.decode)($('script[data-tralbum]').attr('data-tralbum'));
        if (!rawBasic || !rawExtra) {
            throw new Parse_js_1.ParseError('Failed to parse track info: data missing \'ld_json\' or \'tralbum\' fields.', html);
        }
        let basic, extra;
        try {
            basic = JSON.parse(rawBasic);
        }
        catch (error) {
            throw new Parse_js_1.ParseError('Failed to parse track info: JSON error in basic data.', rawBasic, error);
        }
        try {
            extra = JSON.parse(rawExtra);
        }
        catch (error) {
            throw new Parse_js_1.ParseError('Failed to parse track info: JSON error in extra data.', rawExtra, error);
        }
        if (!basic || typeof basic !== 'object') {
            throw new Parse_js_1.ParseError('Failed to parse track info: invalid basic data');
        }
        if (!extra || typeof extra !== 'object') {
            throw new Parse_js_1.ParseError('Failed to parse track info: invalid extra data');
        }
        const track = {
            type: 'track',
            name: basic.name,
            url: basic['@id']
        };
        const trackId = (0, Parse_js_1.getAdditionalPropertyValue)(basic, 'track_id');
        if (trackId !== undefined && !isNaN(trackId)) {
            track.id = Number(trackId);
        }
        const imageUrl = (0, Parse_js_1.reformatImageUrl)(basic.image, opts.albumImageFormat);
        if (imageUrl) {
            track.imageUrl = imageUrl;
        }
        if (extra.current?.release_date) {
            track.releaseDate = extra.current.release_date;
        }
        const duration = extra.trackinfo?.[0]?.duration;
        if (duration !== undefined) {
            track.duration = duration;
        }
        const streamUrl = extra.trackinfo?.[0]?.file?.['mp3-128'];
        if (streamUrl) {
            track.streamUrl = streamUrl;
        }
        const streamUrlHQ = extra.trackinfo?.[0]?.file?.['mp3-v0'];
        if (streamUrlHQ) {
            track.streamUrlHQ = streamUrlHQ;
        }
        let byArtist;
        if (basic.inAlbum?.byArtist) {
            byArtist = basic.inAlbum.byArtist;
        }
        else {
            byArtist = basic.byArtist;
        }
        if (byArtist) {
            track.artist = {
                name: byArtist.name
            };
            if (byArtist['@id']) {
                track.artist.url = byArtist['@id'];
            }
        }
        const publisher = (0, Parse_js_1.parsePublisher)(basic, opts.artistImageFormat);
        if (publisher) {
            track.publisher = publisher;
        }
        if (track.artist && !track.artist.url && publisher?.url) {
            track.artist.url = publisher.url;
        }
        const label = (0, Parse_js_1.parseLabelFromBackToLabelLink)($);
        if (label) {
            track.label = {
                name: label.name,
                url: label.url
            };
        }
        if (basic.inAlbum?.['@id']) {
            track.album = {
                name: basic.inAlbum.name,
                url: basic.inAlbum['@id'],
                releaseDate: extra.album_release_date
            };
            track.releaseDate = extra.album_release_date;
        }
        if (basic.recordingOf?.lyrics?.text !== undefined) {
            track.lyrics = basic.recordingOf?.lyrics?.text;
        }
        if (opts.includeRawData) {
            track.raw = { basic, extra };
        }
        return track;
    }
}
_a = TrackInfoParser, _TrackInfoParser_parseTrackInfoFromAlbum = function _TrackInfoParser_parseTrackInfoFromAlbum(html, opts, trackPosition) {
    const album = AlbumInfoParser_js_1.default.parseInfo(html, opts);
    const trackData = album.tracks?.[trackPosition - 1];
    if (trackData) {
        const track = {
            type: 'track',
            id: trackData.id,
            name: trackData.name,
            url: trackData.url,
            imageUrl: album.imageUrl,
            releaseDate: album.releaseDate,
            duration: trackData.duration,
            artist: album.artist,
            publisher: album.publisher,
            label: album.label,
            album: {
                id: album.id,
                name: album.name,
                url: album.url,
                releaseDate: album.releaseDate
            }
        };
        if (trackData.streamUrl) {
            track.streamUrl = trackData.streamUrl;
        }
        return track;
    }
    throw new Parse_js_1.ParseError(`Track not found in album (position: ${trackPosition}`, html);
};
exports.default = TrackInfoParser;
//# sourceMappingURL=TrackInfoParser.js.map