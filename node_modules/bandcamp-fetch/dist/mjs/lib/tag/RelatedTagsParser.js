var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _RelatedTagsParser_parseTags;
import { ParseError } from "../utils/Parse.js";
class RelatedTagsParser {
    static parseRelatedTags(json) {
        if (typeof json === 'object') {
            const result = {
                single: [],
                combo: []
            };
            if (json.single_results && Array.isArray(json.single_results)) {
                result.single = json.single_results.reduce((acc, v) => {
                    if (typeof v === 'object' && v.tag && v.tag.name && v.tag.norm_name && Array.isArray(v.related_tags)) {
                        const tag = {
                            type: 'tag',
                            name: v.tag.name,
                            value: v.tag.norm_name
                        };
                        acc.push({
                            tag,
                            related: __classPrivateFieldGet(this, _a, "m", _RelatedTagsParser_parseTags).call(this, v.related_tags)
                        });
                    }
                    return acc;
                }, []);
            }
            if (json.combo_results && Array.isArray(json.combo_results)) {
                result.combo = __classPrivateFieldGet(this, _a, "m", _RelatedTagsParser_parseTags).call(this, json.combo_results);
            }
            return result;
        }
        throw new ParseError('Failed to parse related tags: invalid data', json);
    }
}
_a = RelatedTagsParser, _RelatedTagsParser_parseTags = function _RelatedTagsParser_parseTags(tags) {
    return tags.reduce((result, t) => {
        if (typeof t === 'object' && t.name && t.norm_name) {
            result.push({
                type: 'tag',
                name: t.name,
                value: t.norm_name
            });
        }
        return result;
    }, []);
};
export default RelatedTagsParser;
//# sourceMappingURL=RelatedTagsParser.js.map