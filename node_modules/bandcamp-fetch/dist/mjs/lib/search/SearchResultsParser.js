var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _SearchResultsParser_matchSearchItemTypeWithResult;
import { load as cheerioLoad } from 'cheerio';
import { reformatImageUrl, stripLineBreaks, stripMultipleWhitespaces, substrAfter, substrBefore } from '../utils/Parse.js';
import { SearchItemType } from './SearchAPI.js';
const VALID_RESULT_TYPES = ['artist', 'label', 'album', 'track', 'fan'];
class SearchResultsParser {
    static parseResults(html, opts) {
        const $ = cheerioLoad(html);
        const resultsList = $('li.searchresult');
        const items = [];
        resultsList.each((i, resultListItem) => {
            resultListItem = $(resultListItem);
            const resultInfo = resultListItem.find('.result-info');
            // Common info
            const resultType = resultInfo.children('.itemtype').text().trim().toLowerCase();
            const imgSrc = $('.art img', resultListItem).attr('src');
            const heading = $('.heading a', resultInfo);
            const name = heading.text().trim();
            const url = resultInfo.find('.itemurl').text().trim();
            const imageUrl = reformatImageUrl(imgSrc, resultType === 'album' || resultType === 'track' ? opts.albumImageFormat : opts.artistImageFormat);
            if (!__classPrivateFieldGet(this, _a, "m", _SearchResultsParser_matchSearchItemTypeWithResult).call(this, opts.itemType, resultType) || !name || !url) {
                return true;
            }
            // Other info
            let location, genre, tags, artist, numTracks, duration, releaseDate, album;
            resultInfo.find('.subhead, .genre, .tags, .released, .length').each((i, info) => {
                info = $(info);
                if (info.hasClass('subhead')) {
                    if (resultType === 'artist' || resultType === 'label') {
                        location = info.text().trim();
                    }
                    else if (resultType === 'album' || resultType === 'track') {
                        const infoText = info.text();
                        artist = substrAfter(infoText, 'by ')?.trim();
                        if (resultType === 'track') {
                            album = substrBefore(infoText, ' by');
                            if (album) {
                                album = substrAfter(album, 'from ')?.trim();
                            }
                        }
                    }
                    return true;
                }
                if (info.hasClass('genre')) {
                    genre = substrAfter(info.text(), 'genre: ')?.trim();
                    return true;
                }
                if (info.hasClass('tags')) {
                    tags = substrAfter(info.text(), 'tags:');
                    if (tags) {
                        tags = stripLineBreaks(stripMultipleWhitespaces(tags)).trim();
                    }
                    return true;
                }
                if (info.hasClass('released')) {
                    releaseDate = substrAfter(info.text(), 'released ')?.trim();
                    return true;
                }
                if (info.hasClass('length')) {
                    const lengthParts = info.text().split(',');
                    const tracksText = lengthParts[0];
                    const minutesText = lengthParts[1];
                    const numTracksStr = tracksText ? substrBefore(tracksText, 'tracks') : null;
                    if (numTracksStr) {
                        numTracks = parseInt(numTracksStr, 10);
                    }
                    const durationStr = minutesText ? substrBefore(minutesText, 'minutes') : null;
                    if (durationStr) {
                        duration = parseInt(durationStr, 10) * 60;
                    }
                }
            });
            const base = {
                name: heading.text().trim(),
                url: resultInfo.find('.itemurl').text().trim() || ''
            };
            if (imageUrl) {
                base.imageUrl = imageUrl;
            }
            if (resultType === 'artist') {
                const artist = {
                    type: 'artist',
                    ...base
                };
                if (location)
                    artist.location = location;
                if (genre)
                    artist.genre = genre;
                if (tags)
                    artist.tags = tags;
                items.push(artist);
            }
            else if (resultType === 'label') {
                const label = {
                    type: 'label',
                    ...base
                };
                if (location)
                    label.location = location;
                items.push(label);
            }
            else if (resultType === 'album') {
                const album = {
                    type: 'album',
                    ...base
                };
                if (artist)
                    album.artist = artist;
                if (numTracks)
                    album.numTracks = numTracks;
                if (duration)
                    album.duration = duration;
                if (releaseDate)
                    album.releaseDate = releaseDate;
                if (tags)
                    album.tags = tags;
                items.push(album);
            }
            else if (resultType === 'track') {
                const track = {
                    type: 'track',
                    ...base
                };
                if (artist)
                    track.artist = artist;
                if (album)
                    track.album = album;
                if (releaseDate)
                    track.releaseDate = releaseDate;
                if (tags)
                    track.tags = tags;
                items.push(track);
            }
            else if (resultType === 'fan') {
                const fan = {
                    type: 'fan',
                    ...base
                };
                if (genre)
                    fan.genre = genre;
                items.push(fan);
            }
        });
        let totalPages = parseInt($('.pagelist').find('.pagenum').last().text(), 10);
        if (isNaN(totalPages)) {
            totalPages = 1;
        }
        return {
            items,
            totalPages
        };
    }
}
_a = SearchResultsParser, _SearchResultsParser_matchSearchItemTypeWithResult = function _SearchResultsParser_matchSearchItemTypeWithResult(searchType, resultType) {
    if (searchType === SearchItemType.All && VALID_RESULT_TYPES.includes(resultType)) {
        return true;
    }
    switch (searchType) {
        case SearchItemType.ArtistsAndLabels:
            return resultType === 'artist' || resultType === 'label';
        case SearchItemType.Albums:
            return resultType === 'album';
        case SearchItemType.Tracks:
            return resultType === 'track';
        case SearchItemType.Fans:
            return resultType === 'fan';
        default:
            return false;
    }
};
export default SearchResultsParser;
//# sourceMappingURL=SearchResultsParser.js.map